//! ONION_CLIENT_AUTH_VIEW response parsing.
//!
//! This module parses responses from the `ONION_CLIENT_AUTH_VIEW` command,
//! which lists client authentication credentials for v3 hidden services.
//! These credentials allow access to hidden services that require client
//! authentication.
//!
//! # Response Format
//!
//! A successful response lists credentials for one or all hidden services:
//!
//! ```text
//! 250-ONION_CLIENT_AUTH_VIEW [service_id]
//! 250-CLIENT <service_id> <key_type>:<private_key> [ClientName=<name>] [Flags=<flags>]
//! 250 OK
//! ```
//!
//! # Example
//!
//! ```rust
//! use stem_rs::response::{ControlMessage, OnionClientAuthViewResponse};
//!
//! let response_text = "250-ONION_CLIENT_AUTH_VIEW\r\n\
//!                      250-CLIENT service1 x25519:privatekey123\r\n\
//!                      250 OK\r\n";
//! let msg = ControlMessage::from_str(response_text, None, false).unwrap();
//! let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
//!
//! let cred = response.credentials.get("service1").unwrap();
//! assert_eq!(cred.key_type, "x25519");
//! ```
//!
//! # Security Considerations
//!
//! - Private keys should be handled securely and not logged
//! - Credentials provide access to hidden services; protect them accordingly
//! - The `Permanent` flag indicates credentials persist across Tor restarts
//!
//! # See Also
//!
//! - [Tor Control Protocol: ONION_CLIENT_AUTH_VIEW](https://spec.torproject.org/control-spec/commands.html#onion_client_auth_view)

use std::collections::HashMap;

use super::ControlMessage;
use crate::Error;

/// Client authentication credential for a v3 hidden service.
///
/// Contains the cryptographic key and metadata needed to authenticate
/// to a hidden service that requires client authentication.
///
/// # Example
///
/// ```rust
/// use stem_rs::response::{ControlMessage, OnionClientAuthViewResponse};
///
/// let msg = ControlMessage::from_str(
///     "250-ONION_CLIENT_AUTH_VIEW\r\n\
///      250-CLIENT myservice x25519:secretkey ClientName=alice Flags=Permanent\r\n\
///      250 OK\r\n",
///     None,
///     false
/// ).unwrap();
///
/// let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
/// let cred = response.credentials.get("myservice").unwrap();
///
/// assert_eq!(cred.key_type, "x25519");
/// assert_eq!(cred.client_name, Some("alice".to_string()));
/// assert!(cred.flags.contains(&"Permanent".to_string()));
/// ```
///
/// # Security
///
/// The `private_key` field contains sensitive cryptographic material.
/// Handle it securely and avoid logging or displaying it.
#[derive(Debug, Clone)]
pub struct HiddenServiceCredential {
    /// The hidden service address (without `.onion` suffix).
    ///
    /// For v3 services, this is a 56-character base32 string.
    pub service_id: String,

    /// The base64-encoded private key for authentication.
    ///
    /// This is the client's private key used to prove identity to the
    /// hidden service. Keep this value secure.
    pub private_key: String,

    /// The cryptographic algorithm used for the key.
    ///
    /// Currently, v3 hidden services use `x25519` for client authentication.
    pub key_type: String,

    /// Optional human-readable name for this credential.
    ///
    /// Useful for identifying which credential is which when multiple
    /// credentials are stored.
    pub client_name: Option<String>,

    /// Flags associated with this credential.
    ///
    /// Common flags:
    /// - `Permanent`: Credential persists across Tor restarts
    /// - `Generated`: Credential was generated by Tor (not imported)
    pub flags: Vec<String>,
}

/// Parsed response from the ONION_CLIENT_AUTH_VIEW command.
///
/// Contains credentials for accessing v3 hidden services that require
/// client authentication.
///
/// # Example
///
/// ```rust
/// use stem_rs::response::{ControlMessage, OnionClientAuthViewResponse};
///
/// // View all credentials
/// let msg = ControlMessage::from_str(
///     "250-ONION_CLIENT_AUTH_VIEW\r\n\
///      250-CLIENT service1 x25519:key1\r\n\
///      250-CLIENT service2 x25519:key2\r\n\
///      250 OK\r\n",
///     None,
///     false
/// ).unwrap();
///
/// let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
/// assert!(response.requested.is_none()); // Viewing all
/// assert_eq!(response.credentials.len(), 2);
/// ```
#[derive(Debug, Clone)]
pub struct OnionClientAuthViewResponse {
    /// The specific service ID that was requested, if any.
    ///
    /// `None` if viewing all credentials, `Some(service_id)` if viewing
    /// credentials for a specific hidden service.
    pub requested: Option<String>,

    /// Map of service IDs to their credentials.
    ///
    /// Keys are hidden service addresses (without `.onion` suffix).
    pub credentials: HashMap<String, HiddenServiceCredential>,
}

impl OnionClientAuthViewResponse {
    /// Parses an ONION_CLIENT_AUTH_VIEW response from a control message.
    ///
    /// Extracts credentials for one or all hidden services from the response.
    ///
    /// # Arguments
    ///
    /// * `message` - The control message to parse
    ///
    /// # Errors
    ///
    /// Returns [`Error::Protocol`] if:
    /// - The response status is not OK
    /// - The response is empty
    /// - The response doesn't start with "ONION_CLIENT_AUTH_VIEW"
    /// - A CLIENT line has fewer than 3 fields
    /// - A CLIENT line doesn't start with "CLIENT"
    /// - The credential format is invalid (missing `:` separator)
    /// - An attribute is not a key=value mapping
    ///
    /// # Example
    ///
    /// ```rust
    /// use stem_rs::response::{ControlMessage, OnionClientAuthViewResponse};
    ///
    /// // View credentials for a specific service
    /// let msg = ControlMessage::from_str(
    ///     "250-ONION_CLIENT_AUTH_VIEW myservice\r\n\
    ///      250-CLIENT myservice x25519:secretkey\r\n\
    ///      250 OK\r\n",
    ///     None,
    ///     false
    /// ).unwrap();
    ///
    /// let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
    /// assert_eq!(response.requested, Some("myservice".to_string()));
    /// assert!(response.credentials.contains_key("myservice"));
    /// ```
    pub fn from_message(message: &ControlMessage) -> Result<Self, Error> {
        if !message.is_ok() {
            return Err(Error::Protocol(format!(
                "ONION_CLIENT_AUTH_VIEW response didn't have an OK status: {}",
                message
            )));
        }

        let mut requested = None;
        let mut credentials = HashMap::new();

        let lines: Vec<String> = message.iter().map(|l| l.to_string()).collect();

        if lines.is_empty() {
            return Err(Error::Protocol(
                "Empty ONION_CLIENT_AUTH_VIEW response".to_string(),
            ));
        }

        let first_line = &lines[0];
        if !first_line.starts_with("ONION_CLIENT_AUTH_VIEW") {
            return Err(Error::Protocol(format!(
                "Response should begin with 'ONION_CLIENT_AUTH_VIEW': {}",
                message
            )));
        }

        if first_line.contains(' ') {
            let parts: Vec<&str> = first_line.split(' ').collect();
            if parts.len() > 1 {
                requested = Some(parts[1].to_string());
            }
        }

        for line in lines.iter().skip(1) {
            if line == "OK" {
                continue;
            }

            let attributes: Vec<&str> = line.split(' ').collect();

            if attributes.len() < 3 {
                return Err(Error::Protocol(format!(
                    "ONION_CLIENT_AUTH_VIEW lines must contain an address and credential: {}",
                    message
                )));
            }

            if attributes[0] != "CLIENT" {
                return Err(Error::Protocol(format!(
                    "ONION_CLIENT_AUTH_VIEW lines should begin with 'CLIENT': {}",
                    message
                )));
            }

            if !attributes[2].contains(':') {
                return Err(Error::Protocol(format!(
                    "ONION_CLIENT_AUTH_VIEW credentials must be of the form 'encryption_type:key': {}",
                    message
                )));
            }

            let service_id = attributes[1].to_string();
            let (key_type, private_key) = attributes[2].split_once(':').unwrap();

            let mut client_name = None;
            let mut flags = Vec::new();

            for attr in attributes.iter().skip(3) {
                if !attr.contains('=') {
                    return Err(Error::Protocol(format!(
                        "'{}' expected to be a 'key=value' mapping: {}",
                        attr, message
                    )));
                }

                let (key, value) = attr.split_once('=').unwrap();
                match key {
                    "ClientName" => client_name = Some(value.to_string()),
                    "Flags" => flags = value.split(',').map(|s| s.to_string()).collect(),
                    _ => {}
                }
            }

            credentials.insert(
                service_id.clone(),
                HiddenServiceCredential {
                    service_id,
                    private_key: private_key.to_string(),
                    key_type: key_type.to_string(),
                    client_name,
                    flags,
                },
            );
        }

        Ok(Self {
            requested,
            credentials,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_message(lines: Vec<&str>) -> ControlMessage {
        let parsed: Vec<(String, char, Vec<u8>)> = lines
            .iter()
            .enumerate()
            .map(|(i, line)| {
                let divider = if i == lines.len() - 1 { ' ' } else { '-' };
                ("250".to_string(), divider, line.as_bytes().to_vec())
            })
            .collect();
        let raw = lines.join("\r\n");
        ControlMessage::new(parsed, raw.into_bytes(), None).unwrap()
    }

    #[test]
    fn test_onion_client_auth_view_basic() {
        let msg = create_message(vec![
            "ONION_CLIENT_AUTH_VIEW yvhz3ofkv7gwf5hpzqvhonpr3gbax2cc7dee3xcnt7dmtlx2gu7vyvid",
            "CLIENT yvhz3ofkv7gwf5hpzqvhonpr3gbax2cc7dee3xcnt7dmtlx2gu7vyvid x25519:FCV0c0ELDKKDpSFgVIB8Yow8Evj5iD+GoiTtK878NkQ=",
            "OK",
        ]);
        let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
        assert_eq!(
            response.requested,
            Some("yvhz3ofkv7gwf5hpzqvhonpr3gbax2cc7dee3xcnt7dmtlx2gu7vyvid".to_string())
        );
        assert_eq!(response.credentials.len(), 1);

        let cred = response
            .credentials
            .get("yvhz3ofkv7gwf5hpzqvhonpr3gbax2cc7dee3xcnt7dmtlx2gu7vyvid")
            .unwrap();
        assert_eq!(cred.key_type, "x25519");
        assert_eq!(
            cred.private_key,
            "FCV0c0ELDKKDpSFgVIB8Yow8Evj5iD+GoiTtK878NkQ="
        );
    }

    #[test]
    fn test_onion_client_auth_view_all_credentials() {
        let msg = create_message(vec![
            "ONION_CLIENT_AUTH_VIEW",
            "CLIENT service1 x25519:key1",
            "CLIENT service2 x25519:key2",
            "OK",
        ]);
        let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
        assert!(response.requested.is_none());
        assert_eq!(response.credentials.len(), 2);
    }

    #[test]
    fn test_onion_client_auth_view_with_client_name() {
        let msg = create_message(vec![
            "ONION_CLIENT_AUTH_VIEW",
            "CLIENT service1 x25519:key1 ClientName=myname",
            "OK",
        ]);
        let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
        let cred = response.credentials.get("service1").unwrap();
        assert_eq!(cred.client_name, Some("myname".to_string()));
    }

    #[test]
    fn test_onion_client_auth_view_with_flags() {
        let msg = create_message(vec![
            "ONION_CLIENT_AUTH_VIEW",
            "CLIENT service1 x25519:key1 Flags=Permanent,Generated",
            "OK",
        ]);
        let response = OnionClientAuthViewResponse::from_message(&msg).unwrap();
        let cred = response.credentials.get("service1").unwrap();
        assert_eq!(cred.flags, vec!["Permanent", "Generated"]);
    }

    #[test]
    fn test_onion_client_auth_view_missing_header() {
        let msg = create_message(vec!["CLIENT service1 x25519:key1", "OK"]);
        assert!(OnionClientAuthViewResponse::from_message(&msg).is_err());
    }

    #[test]
    fn test_onion_client_auth_view_malformed_credential() {
        let msg = create_message(vec![
            "ONION_CLIENT_AUTH_VIEW",
            "CLIENT service1 malformed_no_colon",
            "OK",
        ]);
        assert!(OnionClientAuthViewResponse::from_message(&msg).is_err());
    }
}
